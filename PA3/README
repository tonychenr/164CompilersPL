README file for Programming Assignment 3
========================================

Your directory should now contain the following files:

 build.xml
 PA3.pdf
 cool-manual.pdf
 README
 cool.cup
 bad.cl
 good.cl
 tests/*
 compare-parser.py
 coolc.py
 parser.py
 mycoolc.py
 myparser.py
 runmips.py
 coolc.jar
 trap_handler.mars
 cool-tree.java
 cool-tree.aps
 AbstractSymbol.java
 AbstractTable.java
 BoolConst.java
 CgenClassTable.java	  
 CgenNode.java
 CgenSupport.java
 ClassTable.java
 CoolParser.java
 CoolTokenLexer.java
 Flags.java
 IdSymbol.java
 IdTable.java
 IntSymbol.java
 IntTable.java
 ListNode.java
 Parser.java
 StringSymbol.java
 StringTable.java
 SymbolTable.java
 TokenConstants.java
 TreeConstants.java
 TreeNode.java
 Utilities.java
 *.java			  other generated files

	The build.xml contains targets for compiling and running your
	program. DO NOT MODIFY.
   
	PA3.pdf is the specification of the third programming assignment.
	Please read it carefully.

	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.cup is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the CUP documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	tests is a directory containing ten test cases. DO NOT MODIFY.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).  From
	this file, cool-tree.java is automatically generated by a
	utility that compiles the specification into Java classes for
	constructing tree nodes.  This file is provided for your
	reference.  DO NOT MODIFY.

        TreeNode.java and ListNode.java contain definitions used by the
        tree package. DO NOT MODIFY.  

        Parser.java contains a driver to test the parser. DO NOT MODIFY.

	Flags.java implements routines for parsing command line
	flags. DO NOT MODIFY.

        tests is a directory containing ten test cases with expected outputs.
        DO NOT MODIFY.

        The rest of the files are created as byproducts of `CUP', or
        are internal parser support files.  DO NOT MODIFY.
        `CoolParser.java' is the generated Java file containing the
        parser.  DO NOT MODIFY this file directly; instead, edit
        cool.cup and this file will be regenerated automatically.

	myparser.py and parser.py are a python script driveing the parser.
	compare-parser.py is a python script which compares the outcome
	of your parser with the reference. DO NOT MODIFY.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% ant parser

	To test your parser on a file 'foo.cl' type

	% python myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.  Don't worry if the line numbers you get by
	running Java version of the parser are slightly off as compared
	to the "official" parser.

	To run your parser on the files good.cl and bad.cl type:

	% ant test

        To run ten examples in tests directory type:

        % ant test-all

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% python mycoolc.py foo.cl

        To run the reference parser on a file 'fool.cl':

        % pythone parser.py foo.cl

        To easily compare your parser and the reference parser:

        % python compare-parser.py foo.cl

        This will create a diff file (fool.cl.diff), when two parsers
	disagree.

	To turn in your work type:

	% ant submit-clean

	And run the "submit PA3" program. This will automatically collect the
	files good.cl, bad.cl, good.output, bad.output, README, and cool.cup 
        file. Don't forget to edit this README file to include your write-up, 
        and to write your own test cases in good.cl and bad.cl.

 	You may turn in the assignment as many times as you like.
	However, only the last version will be retained for
	grading.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------

We handled let statement ambiguity by putting the precedence of the let statement
below all the rest. By doing this, we ensure that the parser will always shift
instead of reducing the let statement. As we saw in lecture, we shift if the precedence
of the input terminal is higher.

In good.cl, we tested many of the cool syntax elements by going down the list.
When we placed the precedence of the let statement in the wrong place, it failed
the test for let ambiguity in good.cl. It passes with the precedence we put in and
by default as well.

In bad.cl, we tested error handling. To test if the parser recovers from a specific
error in class list, feature list, let binding, or expressions in blocks, we introduced
an error, then followed it with another error to see if the parser caught that next error.
We tested to see if the parser recovered when a class had and open bracket and no closing
bracket, but had a semicolon using the method described above. We saw this interesting case
from a piazza post and decided to test it.

In bad.cl, we also tested what would happen if there was a bad let binding at the end
of the let bindings. We expected it to recover, but the example parser found the error
and terminated. We realized a bug in our parser where it continued onward instead. We 
fixed the behavior to emulate the example parser by requiring the error to be followed by
a comma and a recursion on the production.
