README file for Programming Assignment 2 
=========================================

Your directory should now contain the following files:

 build.xml
 PA2.pdf
 cool-manual.pdf
 README
 cool.lex
 test.cl
 tests/*
 AbstractSymbol.java 
 BoolConst.java
 Flags.java
 IdSymbol.java
 IdTable.java
 IntSymbol.java
 IntTable.java
 Lexer.java 
 AbstractTable.java
 StringSymbol.java
 StringTable.java
 Utilities.java
 TokenConstants.java
 *.java		      other generated files
 coolc.jar
 trap_handler.mars 
 coolc.py
 mycoolc.py
 lexer.py
 mylexer.py
 runmips.py

	build.xml contains targets for compiling and running your
	program. DO NOT MODIFY.

	PA2.pdf is the specification of the second programming assignment.
	Please read it carefully.

	cool-manual.pdf is the specification of the cool language syntax
	and semantics. Please read it carefully.

	README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code. Just edit this file.

	cool.lex is a skeleton file for the specification of the
	lexical analyzer. You should complete it with your regular
	expressions, patterns and actions. Information on how to do this
	is in the jlex manual, which is part of your reader.

	test.cl is a COOL program that you can test the lexical
	analyzer on. It contains some errors, so it won't compile with
	coolc. However, test.cl does not exercise all lexical
	constructs of COOL and part of your assignment is to rewrite
	test.cl with a complete set of tests for your lexical analyzer.

	tests is a directory containing five test cases with expected outputs.
	DO NOT MODIFY.

	TokenConstants.java contains constant definitions that are used by
	almost all parts of the compiler. DO NOT MODIFY.

	*Table.java and *Symbol.java contain string table data
	structures.  DO NOT MODIFY.

	Utilities.java contains various support functions used by the
        main lexer driver (Lexer.java).  DO NOT MODIFY.

        Lexer.java contains the main method which will call your lexer
        and print out the tokens that it returns.  DO NOT MODIFY.

	CoolLexer.java is the scanner generated by jlex from cool.lex.
	DO NOT MODIFY IT, as your changes will be overritten the next
	time you run jlex.

	coolc.jar is a jar file containing the reference implementation 
	with other libraries required for programming assignment. DO NOT MODIFY.

	trap_handler.mars is a trap handler implementation required
	by the MART mips emulator. DO NOT MODIFY.

	mycoolc.py and coolc.py are a python script that glues together the
	phases of the compiler using Unix pipes instead of statically linking
	code. While inefficient, this architecture makes it easy to mix and match
	the components you write with those of the course compiler.
	DO NOT MODIFY.	

	mylexer.py and lexer.py are a python script to drive the lexer. 
	DO NOT MODIFY.

Instructions
------------
	To compile your lexer implementation:

	% ant lexer

	Run your lexer by putting your test input in a file 'foo.cl' and
	run the lextest program:

	% python mylexer.py foo.cl

	To run your lexer on the file test.cl type:

	% ant test

	To run five examples in tests directory type:

	% ant test-all

	If you think your lexical analyzer is correct and behaves like
	the one we wrote, you can actually try 'mycoolc.py' and see whether
	it runs and produces correct code for the examples and your
	first assignment. If your lexical analyzer behaves in an
	unexpected manner, you may get errors anywhere, i.e. during
	parsing, during semantic analysis, during code generation or
	only when you run the produced code on spim. So beware.
	You can also use 'coolc.py' to drive the referce compiler or
	'lexer.py' to drive just the reference lexer. 

	To turnin your work type:

	% ant submit-clean

	And run the "submit" program following the instructions on the
	course web page.
	
	Running "submit" will collect the files cool.lex, test.cl,
	README, and test.output. Don't forget to edit the README file to
	include your write-up, and to write your own test cases in
	test.cl.

 	You may turn in the assignment as many times as you like.
	However, only the last version will be retained for
	grading.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA2
----------------

Single line comments implementation:
Encountering a "--" in YYINITIAL causes state change to LINE_COMMENT. Here we do nothing
until we hit a '\n', when we return to YYINITIAL.

Multiline comments implementation:
We used an int to keep track of the current comment depth. When we encounter a "(*"
in YYINITIAL, comment_depth is set to 1 and we enter MULTILINE_COMMENT state.
In the MULTILINE_COMMENT state, a  "(*" increments comment_depth (went 1 level deeper)
and a "*)" decrements it (exited from current level). After a "(*", if comment_depth
is 0, we have exited the initial comment and must return to YYINITIAL. Any other
intermediate characters are ignored.

Strings implementation:
Upon encountering a quotation mark in YYINITIAL we enter the STRING state. Here we do
casework for all the valid escape characters (\t, \n, \r, \b, \f). A naked '\n'
(without a '\' prededing it) and '\0' in a string return ERROR. After a '\0\ null
character we enter the STRING_ERROR state, where we ignore everything until a newline
or quotation mark, and then go back to YYINITIAL. Any other escapedcharacters are
appended without the '\'. We also handled special cases for input of '\' followed by
newline (to allow escaped newline characters) and '\' followed by quotation mark (so
that escaped quotations dont exit us from the string). All other characters are just
appended to the string as-is. When we reach a non-escaped quotation mark we just return
what is in the string buffer and return to YYINITIAL.

Other:
We added cases for "<-" (ASSIGN) and "<=" (LE) because they were not in the skeleton code.
We did object ID and type ID lexing with single regex expressions [a-z][A-Za-z0-9\_]* and
[A-Z][A-Za-z0-9\_]*.
We added an EOF state to avoid an infinite loop at EOF. When we first enter %eofval, the
appropriate action is taken depending on current state, and then state is switched to EOF.
When we enter %eofval with state EOF (second time) we just return the EOF symbol.